---
title: "RDR Scenarios from AequilibraE Runs"
output: 
  html_document:
    self_contained: true
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: true
      smooth_scroll: false
params:
  input_dir: 'C:/GitHub/RDR/Data/SampleRun/inputs'
  output_dir: 'C:/GitHub/RDR/Data/SampleRun/generated_files'
  run_id: 'SampleRun'
  method: 'multitarget'  # options are 'base', 'interact', 'projgroupLM', 'multitarget' (default), 'mixedeffects'
  run_disaggregate: 'no'
  testing: false

---
<!-- https://cran.r-project.org/web/packages/mlegp/vignettes/mlegp.pdf -->

```{r setup, include=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE
)
options(warn = -1) # Suppress warnings

use_lib <- ifelse(any(grepl("RDRenv", .libPaths())),
  .libPaths()[grepl("RDRenv", .libPaths())],
  .libPaths()
)

suppressPackageStartupMessages(library(dplyr, lib.loc = use_lib))
suppressPackageStartupMessages(library(DT, lib.loc = use_lib))
suppressPackageStartupMessages(library(knitr, lib.loc = use_lib))
suppressPackageStartupMessages(library(lme4, lib.loc = use_lib))  # used for 'mixedeffects' method
suppressPackageStartupMessages(library(mlegp, lib.loc = use_lib))  # used for Gaussian Process regression for 'multitarget' method
suppressPackageStartupMessages(library(nlme, lib.loc = use_lib))  # used for 'projgroupLM' method
suppressPackageStartupMessages(library(readxl, lib.loc = use_lib))
suppressPackageStartupMessages(library(sjPlot, lib.loc = use_lib))

input_dir <- params$input_dir
output_dir <- params$output_dir

run_id <- params$run_id
run_disaggregate <- params$run_disaggregate

if (!file.exists(file.path(output_dir, paste0("AequilibraE_Runs_Compiled_", run_id, ".xlsx")))) {
  stop(paste0("Error: could not find AequilibraE_Runs_Compiled_", run_id, ".xlsx file."))
}

d <- read_excel(file.path(output_dir, paste0("AequilibraE_Runs_Compiled_", run_id, ".xlsx")))

# Clean up by deleting rows where values are the headings
extra_heading_rows <- vector()
for (i in 1:nrow(d)) {
  extra_heading_rows <- c(extra_heading_rows, all(make.names(d[i, ]) == make.names(names(d))))
}

d <- d[!extra_heading_rows, ]

# Omit duplicate scenarios
names(d) <- make.names(names(d))

d <- d[!duplicated(paste(d$Scenario, d$SP.RT)), ]

# Format column types

d <- d %>%
  mutate(
    Type = as.factor(Type),
    SP.RT = as.factor(SP.RT),
    socio = as.factor(socio),
    projgroup = as.factor(projgroup),
    resil = as.factor(resil),
    elasticity = as.factor(elasticity),
    hazard = as.factor(hazard),
    recovery = as.factor(recovery),
    recovery_num = as.numeric(as.character(recovery)),
    trips = as.numeric(trips),
    miles = as.numeric(miles),
    hours = as.numeric(hours),
    lost_trips = as.numeric(lost_trips),
    extra_miles = as.numeric(extra_miles),
    extra_hours = as.numeric(extra_hours),
    circuitous_trips_removed = as.numeric(circuitous_trips_removed)
  )

if(run_disaggregate == 'yes'){
  d <- d %>%
    mutate(
      lr_trips = as.numeric(lr_trips),
      hr_trips = as.numeric(hr_trips),
      bus_trips = as.numeric(bus_trips),
      car_trips = as.numeric(car_trips),
      lr_miles = as.numeric(lr_miles),
      hr_miles = as.numeric(hr_miles),
      bus_miles = as.numeric(bus_miles),
      car_miles = as.numeric(car_miles),
      lr_hours_wait = as.numeric(lr_hours_wait),
      hr_hours_wait = as.numeric(hr_hours_wait),
      bus_hours_wait = as.numeric(bus_hours_wait),
      lr_hours_enroute = as.numeric(lr_hours_enroute),
      hr_hours_enroute = as.numeric(hr_hours_enroute),
      bus_hours_enroute = as.numeric(bus_hours_enroute),
      car_hours = as.numeric(car_hours)
    )
}

d$resil <- relevel(d$resil, ref = "no")
```

# Overview

The RDR Metamodel has the following steps:

- Calculate the total number of combinations possible based on these variables:
  + `socio`
  + `projgroup`
  + `resil`
  + `elasticity`
  + `hazard`
  + `recovery`
- Run regressions on `trips`, `miles`, and `hours` from the AequilibraE runs.
- Conduct these steps for both shortest path (`SP`) and routing (`RT`) options of AequilibraE runs.
- Run regressions on transit and car metrics for routing (`RT`) option if specified.
- Use those coefficients to generate interpolations for the other combinations which were not run in AequilibraE.
- Provide visualizations.

Total number of combinations possible with these inputs:

```{r combocalsc, warning=FALSE, message=FALSE}

if (!file.exists(file.path(output_dir, paste0("full_combos_", run_id, ".csv")))) {
  stop(paste0("Error: could not find full_combos_", run_id, ".csv file."))
}

full_combos <- read.csv(file.path(output_dir, paste0("full_combos_", run_id, ".csv")),
  colClasses = c(
    "socio" = "factor", "projgroup" = "factor", "hazard" = "factor",
    "recovery" = "factor", "resil" = "factor"
  )
)

full_combos <- full_combos %>%
  mutate(across(where(is.integer), as.factor)) %>%
  mutate(across(where(is.numeric), as.factor))

# Ensure that 'no' is the reference level for the resil column
full_combos$resil <- relevel(full_combos$resil, ref = "no")

stopifnot(all(sapply(full_combos, class) == "factor"))

predictors <- names(full_combos)

groups <- "SP.RT"

use_levels <- lapply(
  d[predictors],
  function(x) levels(x)
)

use_groups <- lapply(
  d[groups],
  function(x) levels(x)
)

# from full_combos, only select variables which have more than one level
use_pred_vars <- names(full_combos)[sapply(full_combos, function(x) length(levels(x)) > 1)]

full_groups <- expand.grid(use_groups)

d_in <- d %>%
  filter(Type == "Disrupt") %>%
  group_by(get(groups))

d_in_sp <- d_in %>%
  filter(SP.RT == "SP")

d_in_rt <- d_in %>%
  filter(SP.RT == "RT")

max_avail_combos <- d_in %>%
  summarize(combo_count = n()) %>%
  ungroup() %>%
  summarize(max = max(combo_count)) %>%
  select(max)
```

```{r test_Gaussian, message=FALSE, echo=FALSE, results = 'hide'}
# If starting with multitarget as method, need to ensure both SP and RT will be able to be fit
# If not, go back to base

# Pull out the SP and RT data frames from the compiled Aeq runs
d_sp <- d_in %>% filter(SP.RT == "SP")
d_rt <- d_in %>% filter(SP.RT == "RT")

if(params$method == 'multitarget'){
  
  tryGaussian <- function(predictors, responses){
    gaussian_fit <- tryCatch(
      # Try
      {
        message('Trying Gaussian process regression')
        mlegp(predictors, responses) 
      },
      # Error
      error = function(cond) {
        message('Failed - specify a different method, such as linear regression')
        
      })
    return(gaussian_fit)
  }
  
  # First for shortest path
  responses <- d_sp[, c("trips", "miles", "hours")]
  
  predictors <- d_sp[use_pred_vars]
  class(predictors) <- "data.frame"
  for (p in use_pred_vars) {
    predictors[, p] <- as.numeric(predictors[, p])
  }
  
  spfit <- tryGaussian(predictors, responses)
  
  # Second for routing
  if(run_disaggregate == 'yes'){
    responses <- d_rt[, c("trips", "miles", "hours", "lr_trips", "hr_trips",
                          "bus_trips", "car_trips", "lr_miles", "hr_miles",
                          "bus_miles", "car_miles", "lr_hours_wait",
                          "hr_hours_wait", "bus_hours_wait", "lr_hours_enroute",
                          "hr_hours_enroute", "bus_hours_enroute", "car_hours")]
  } else {
    responses <- d_rt[, c("trips", "miles", "hours")]
  }
  
  predictors <- d_rt[use_pred_vars]
  class(predictors) <- "data.frame"
  for (p in use_pred_vars) {
    predictors[, p] <- as.numeric(predictors[, p])
  }
  
  rtfit <- tryGaussian(predictors, responses)
  
  # If both pass, they will have class gp.list
  use_method = ifelse(class(spfit) == 'gp.list' & class(rtfit) == 'gp.list',
                           "multitarget",
                           "base")
  
  if(use_method == 'base' & params$method == 'multitarget'){
    # If the method has changed, generate a warning. Log that warning as well.
    warn_change_method = 'The method `multitarget` was selected, but the Gaussian mulitarget regression could not be completed for both shortest path and routing methods. This is likely a result of too few samples being selected in the LHS. The regression method `base` is being used as a fallback.'
    warning(warn_change_method)
    
    # Write out a small file to trigger a log file entry
    fileConn <- file(file.path(output_dir, "MethodChange.txt"))
    writeLines(warn_change_method, fileConn)
    close(fileConn)
  }

} else {
  use_method = params$method
}
```

There are **`r nrow(full_combos)`** combinations possible with these provided inputs for each of `r nrow(full_groups)` groups of models. Of these, **`r as.numeric(max_avail_combos)`** combinations have been run in AequilibraE; these provide the input for the metamodel.

```{r, echo=FALSE, results='asis', eval= use_method == 'base' & params$method == 'multitarget'}
# Print an additional paragraph if the method changed
cat("**Note:** ")
cat(warn_change_method)
```

For this analysis, the metamodel approach is ``r use_method``, so the metamodel takes the following form below. Note that the predictors are all categorical, with a separate estimated coefficient for each level of the predictor:

```{r eqn_builder}
# TODO: Create a formula_builder code chunk similar to eqn_builder
Use_Names <- data.frame(
  short = names(full_combos),
  Name = c(
    "DevelopmentScenario",
    "ProjectGroup",
    "Elasticity",
    "Hazard",
    "Recovery",
    "ResilienceInvestment"
  )
)

use_pred_Names <- Use_Names[match(use_pred_vars, Use_Names$short), "Name"]
len_pred <- 1:length(use_pred_vars)

if (use_method == "base") {
  formula_text <- paste0("EstimatedTrips = \\beta_0 + ",
                         paste(paste0("\\beta_", len_pred, " ", use_pred_Names), collapse = " + "),
                         " + \\epsilon")
}

if (use_method == "interact") {
  # Make interaction between hazard and recovery if these exist
  if (all(c("hazard", "recovery") %in% use_pred_vars)) {
    use_pred_Names <- c(use_pred_Names, "Hazard \\times Recovery")
  }

  # Make interaction between resil and projgroup if these exist
  if (all(c("resil", "projgroup") %in% use_pred_vars)) {
    use_pred_Names <- c(use_pred_Names, "Resil \\times ProjectGroup")
    use_pred_Names <- use_pred_Names[!use_pred_Names %in% c("ResilienceInvestment", "ProjectGroup")]
  }

  formula_text <- paste0("EstimatedTrips = \\beta_0 + ",
                         paste(paste0("\\beta_", len_pred, " ", use_pred_Names), collapse = " + "),
                         " + \\epsilon")
}

if (use_method == "projgroupLM") {
  # Make interaction between hazard and recovery if these exist
  if (all(c("hazard", "recovery") %in% use_pred_vars)) {
    use_pred_Names <- c(use_pred_Names, "Hazard \\times Recovery")
  }

  # Make nested term for resil within projgroup if these exist
  # TODO: In this case, 'projgroupLM' is identical to either 'base' or 'interact'
  if ("projgroup" %in% use_pred_vars) {
    use_pred_Names <- use_pred_Names[!use_pred_Names %in% c("ProjectGroup")]
  }

  formula_text <- paste0("EstimatedTrips_j = \\beta_{0,j} + ",
                         paste(paste0("\\beta_{", len_pred, ",j} ", use_pred_Names), collapse = " + "),
                         " + \\epsilon_j")
}

if (use_method == "multitarget") {
  # Single GP
  # http://www.gaussianprocess.org/gpml/chapters/RW2.pdf
  # https://www.researchgate.net/profile/Haitao-Liu-20/publication/322077462_Remarks_on_Multi-Output_Gaussian_Process_Regression/links/5a56db8845851547b1bf2d66/Remarks-on-Multi-Output-Gaussian-Process-Regression.pdf

  # f(x) ∼ GP(m(x), k(x, x'))
  # mean function m and covariance k

  formula_text <- "[EstTrips,EstMiles,EstHours] = \\mathcal{GP}(m(\\boldsymbol{x}),k(\\boldsymbol{x},\\boldsymbol{x}\\prime))"
}

if (use_method == "mixedeffects") {
  # Refer to Gelman textbook for notation for error term of the random slope in resil | projgroup
  # Also reference available in Raudenbush and Bryk (2006) per https://rpubs.com/rslbliss/r_mlm_ws
  formula_text <- paste0("EstimatedTrips_{ij} = \\gamma_{00} + ", paste(paste0("\\gamma_{0", len_pred, "} ", paste0(use_pred_Names, "_{ij}")), collapse = " + "), " + $u$_{0j} + $u$_{1j} Resil_{ij} + \\epsilon_{ij}")
}
```

$$
`r formula_text`
$$

```{r, echo=FALSE, results='asis', eval= use_method =='multitarget'}
cat("Where  $\\boldsymbol{x}$ is the matrix of the input variables", paste(use_pred_Names, collapse = ", "), ".")
cat("With the mean function $m$ and covariance function $k$, see [here](http://www.gaussianprocess.org/gpml/chapters/RW2.pdf) for more details.")
```

```{r, echo=FALSE, results='asis', eval= use_method !='multitarget'}
cat("The metamodel assesses the best-fit values for the $\\beta$ coefficients, as well as the overall uncertainty $\\epsilon$.")
```

```{r, echo=FALSE, results='asis', eval= use_method =='projgroupLM'}
cat("The subscript $j$ denotes the project group; a separate metamodel is fit for each project group.")
```

```{r, echo=FALSE, results='asis', eval= use_method =='mixedeffects'}
cat("The subscript $j$ denotes the project group, with a different slope for each resilience investment.")
```

## Data summaries {.tabset .tabset-pills} 

### Shortest Path vs. Routing solutions
The relationship between Shortest Path and Routing solutions are shown below:

```{r sp_rt_compare, fig.width=8, fig.height=4}

d_in_rt_df <- d_in_rt
class(d_in_rt_df) <- "data.frame"
d_in_sp_df <- d_in_sp
class(d_in_sp_df) <- "data.frame"

par(mfrow = c(1, 3))
for (i in c("trips", "miles", "hours")) {
  plot(as.vector(d_in_rt_df[, i]), as.vector(d_in_sp_df[, i]),
    xlab = paste0(i, " - Routing"), ylab = paste0(i, " - Shortest Path")
  )
  abline(a = 0, b = 1, lty = 2, col = "grey80")
}

par(mfrow = c(1, 3))
for (i in c("lost_trips", "extra_miles", "extra_hours")) {
  plot(as.vector(d_in_rt_df[, i]), as.vector(d_in_sp_df[, i]),
    xlab = paste0(i, " - Routing"), ylab = paste0(i, " - Shortest Path")
  )
  abline(a = 0, b = 1, lty = 2, col = "grey80")
}

# Transit and car metrics are only generated for Routing so no graphs made
```

# Models 

Applying the linear regression models to the input combinations run to date. The metamodel approach **`r use_method`** is being used.

Tables show outputs with scaled response variables for easier interpretation of the coefficients.

## SP Model Statistical Summaries {.tabset .tabset-pills} 

```{r sp_mlGP}
if (use_method == "multitarget") {

  summary(spfit)
  plot(spfit)

  # Summaries
  summary(spfit[[1]])
  summary(spfit[[2]])
  summary(spfit[[3]])

  # AIC
  AIC_trips_sp <- -2 * spfit[[1]]$loglike + 2 * length(spfit[[1]]$params)
  AIC_miles_sp <- -2 * spfit[[2]]$loglike + 2 * length(spfit[[2]]$params)
  AIC_hours_sp <- -2 * spfit[[3]]$loglike + 2 * length(spfit[[3]]$params)
}
```

### `trips` model

```{r modelTrip}
# TODO: Make a formula builder code chunk - e.g., 'DEPENDENT ~ formula' and then
# gsub('DEPENDENT', 'trips'/'miles'/'hours') within each subsequent chunk
# TODO: Need to accommodate for cases where hazard/recovery_num/resil/projgroup
# has 1 level for 'interact', 'projgroupLM', 'mixedeffects' models, currently causes an error

# add socio and elasticity if present
add_vars <- c("socio", "elasticity")[c("socio", "elasticity") %in% use_pred_vars]
use_add_vars <- paste(add_vars, collapse = " + ")
use_add_vars <- if (length(add_vars) > 0) {
  paste(use_add_vars, "+")
}

if (use_method == "base") {
  mTrip <- lm(as.formula(paste0("trips ~ ", paste(use_pred_vars, collapse = " + "))),
    data = d_sp
  )
} else if (use_method == "interact") {
  formula_use <- as.formula(paste0("trips ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + projgroup:resil"))
  mTrip <- lm(formula_use, data = d_sp)
} else if (use_method == "projgroupLM") {
  formula_use <- as.formula(paste0("trips ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + resil | projgroup"))
  mTrip <- lmList(formula_use, data = d_sp)
} else if (use_method == "mixedeffects") {
  formula_use <- as.formula(paste0("trips ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + (1+resil|projgroup)"))
  mTrip <- lmer(formula_use, data = d_sp, control = lmerControl(calc.derivs = FALSE))
} else if (use_method == "multitarget") {
  mTrip <- spfit[[1]]
} else {
  stop("Unknown metamodel approach")
}

if (params$testing) {
  if (use_method == "base" || use_method == "interact") {
    coef(mTrip)
    AIC_trips_sp <- AIC(mTrip)
    sjPlot::tab_model(mTrip)
  } else if (use_method == "projgroupLM") {
    tables <- lapply(mTrip, sjPlot::tab_model)
    tables[[1]]
    AIC_trips_sp_l <- lapply(mTrip, AIC)
    AIC_trips_sp <- sum(unlist(AIC_trips_sp_l))
  } else if (use_method == "mixedeffects") {
    ranef(mTrip)
    AIC_trips_sp <- AIC(logLik(mTrip))
  }
}

if (use_method == "base" || use_method == "interact") {
  if (sd(d_sp$trips) != 0) {
    if (use_method == "base") {
      mTrip_scaled <- lm(as.formula(paste0("scale(trips) ~ ", paste(use_pred_vars, collapse = " + "))),
        data = d_sp
      )
    } else if (use_method == "interact") {
      mTrip_scaled <- lm(as.formula(paste0(
        "scale(trips) ~ ",
        paste(use_add_vars, collapse = " + "),
        " hazard * recovery_num + projgroup:resil"
      )),
      data = d_sp
      )
    }
    sjPlot::tab_model(mTrip_scaled)
  }
}
```

### `miles` model

```{r modelMiles}
if (use_method == "base") {
  mMiles <- lm(as.formula(paste0("miles ~ ", paste(use_pred_vars, collapse = " + "))),
    data = d_sp
  )
} else if (use_method == "interact") {
  formula_use <- as.formula(paste0("miles ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + projgroup:resil"))
  mMiles <- lm(formula_use, data = d_sp)
} else if (use_method == "projgroupLM") {
  formula_use <- as.formula(paste0("miles ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + resil | projgroup"))
  mMiles <- lmList(formula_use, data = d_sp)
} else if (use_method == "mixedeffects") {
  formula_use <- as.formula(paste0("miles ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + (1+resil|projgroup)"))
  mMiles <- lmer(formula_use, data = d_sp, control = lmerControl(calc.derivs = FALSE))
} else if (use_method == "multitarget") {
  mMiles <- spfit[[2]]
} else {
  stop("Unknown metamodel approach")
}

if (params$testing) {
  if (use_method == "base" || use_method == "interact") {
    coef(mMiles)
    AIC_miles_sp <- AIC(mMiles)
    sjPlot::tab_model(mMiles)
  } else if (use_method == "projgroupLM") {
    tables <- lapply(mMiles, sjPlot::tab_model)
    tables[[1]]
    AIC_miles_sp_l <- lapply(mMiles, AIC)
    AIC_miles_sp <- sum(unlist(AIC_miles_sp_l))
  } else if (use_method == "mixedeffects") {
    ranef(mMiles)
    AIC_miles_sp <- AIC(logLik(mMiles))
  }
}

if (use_method == "base" || use_method == "interact") {
  if (sd(d_sp$miles) != 0) {
    if (use_method == "base") {
      mMiles_scaled <- lm(as.formula(paste0("scale(miles) ~ ",
                                            paste(use_pred_vars, collapse = " + "))),
                          data = d_sp
                          )
    } else if (use_method == "interact") {
      mMiles_scaled <- lm(as.formula(paste0(
        "scale(miles) ~ ",
        paste(use_add_vars, collapse = " + "),
        " hazard * recovery_num + projgroup:resil"
      )),
      data = d_sp
      )
    }
    sjPlot::tab_model(mMiles_scaled)
  }
}
```

### `hours` model

```{r modelHours}
if (use_method == "base") {
  mHours <- lm(as.formula(paste0("hours ~ ", paste(use_pred_vars, collapse = " + "))),
    data = d_sp
  )
} else if (use_method == "interact") {
  formula_use <- as.formula(paste0("hours ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + projgroup:resil"))
  mHours <- lm(formula_use, data = d_sp)
} else if (use_method == "projgroupLM") {
  formula_use <- as.formula(paste0("hours ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + resil | projgroup"))
  mHours <- lmList(formula_use, data = d_sp)
} else if (use_method == "mixedeffects") {
  formula_use <- as.formula(paste0("hours ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + (1+resil|projgroup)"))
  mHours <- lmer(formula_use, data = d_sp, control = lmerControl(calc.derivs = FALSE))
} else if (use_method == "multitarget") {
  mHours <- spfit[[3]]
} else {
  stop("Unknown metamodel approach")
}

if (params$testing) {
  if (use_method == "base" || use_method == "interact") {
    coef(mHours)
    AIC_hours_sp <- AIC(mHours)
    sjPlot::tab_model(mHours)
  } else if (use_method == "projgroupLM") {
    tables <- lapply(mHours, sjPlot::tab_model)
    tables[[1]]
    AIC_hours_sp_l <- lapply(mHours, AIC)
    AIC_hours_sp <- sum(unlist(AIC_hours_sp_l))
  } else if (use_method == "mixedeffects") {
    ranef(mHours)
    AIC_hours_sp <- AIC(logLik(mMiles))
  }
}

if (use_method == "base" || use_method == "interact") {
  if (sd(d_sp$hours) != 0) {
    if (use_method == "base") {
      mHours_scaled <- lm(as.formula(paste0("scale(hours) ~ ", paste(use_pred_vars, collapse = " + "))),
        data = d_sp
      )
    } else if (use_method == "interact") {
      mHours_scaled <- lm(as.formula(paste0(
        "scale(hours) ~ ",
        paste(use_add_vars, collapse = " + "),
        " hazard * recovery_num + projgroup:resil"
      )),
      data = d_sp
      )
    }
    sjPlot::tab_model(mHours_scaled)
  }
}

# full_combos
# select only variables which have more than one combination in full_combos
pred_grid <- full_combos[use_pred_vars]
pred_grid$recovery_num <- as.numeric(as.character(pred_grid$recovery))
```

### SP Extrapolate to other combinations

- Applies coefficients from these models to full combinations.
- Output results.

Extrapolating from `r as.numeric(max_avail_combos)` combinations where core models were run to the full set of `r nrow(pred_grid)` combinations of variables.

```{r generate_predictions}

# Static variables
static_vars <- unlist(lapply(use_levels, function(x) length(x) == 1))
static_values <- d[1, names(d) %in% names(static_vars)[static_vars == TRUE]]

# First three outputs: trips, miles, hours
if (use_method != "multitarget") {
  mTrip_pred <- predict(mTrip, newdata = pred_grid)

  mMiles_pred <- predict(mMiles, newdata = pred_grid)

  mHours_pred <- predict(mHours, newdata = pred_grid)
} else {
  # For multitarget, convert to numeric first. Then use argument `newData` instead of `newdata`
  pred_grid_n <- pred_grid[, use_pred_vars]
  class(pred_grid_n) <- "data.frame"
  for (p in use_pred_vars) {
    pred_grid_n[, p] <- as.numeric(pred_grid_n[, p])
  }

  mTrip_pred <- predict(mTrip, newData = pred_grid_n)
  mMiles_pred <- predict(mMiles, newData = pred_grid_n)
  mHours_pred <- predict(mHours, newData = pred_grid_n)
}

preds <- data.frame(static_values, pred_grid,
  trips = mTrip_pred,
  miles = mMiles_pred,
  hours = mHours_pred
)
preds <- preds %>% select(-recovery_num)

if (!dir.exists(output_dir)) {
  dir.create(output_dir)
}

write.csv(preds,
  file = file.path(output_dir, paste0("Metamodel_scenarios_SP_futureyear_", run_id, ".csv")),
  row.names = FALSE
)
```

```{r datatab_sp}
DT::datatable(preds,
  caption = "Extrapolated values for SP routing solution"
) %>%
  formatRound(
    columns = c("trips", "miles", "hours"),
    digits = 0
  ) %>%
  formatStyle(
    "trips",
    background = styleColorBar(preds$trips, "steelblue"),
    backgroundSize = "100% 90%",
    backgroundRepeat = "no-repeat",
    backgroundPosition = "center"
  ) %>%
  formatStyle(
    "miles",
    background = styleColorBar(preds$miles, "salmon"),
    backgroundSize = "100% 90%",
    backgroundRepeat = "no-repeat",
    backgroundPosition = "center"
  ) %>%
  formatStyle(
    "hours",
    background = styleColorBar(preds$hours, "seagreen"),
    backgroundSize = "100% 90%",
    backgroundRepeat = "no-repeat",
    backgroundPosition = "center"
  )
```


## RT Model Statistical Summaries {.tabset .tabset-pills} 

```{r rt_mlGP}
if (use_method == "multitarget") {

  summary(rtfit)
  plot(rtfit)

  # Summaries
  summary(rtfit[[1]])
  summary(rtfit[[2]])
  summary(rtfit[[3]])

  # AIC
  AIC_trips_rt <- -2 * rtfit[[1]]$loglike + 2 * length(rtfit[[1]]$params)
  AIC_miles_rt <- -2 * rtfit[[2]]$loglike + 2 * length(rtfit[[2]]$params)
  AIC_hours_rt <- -2 * rtfit[[3]]$loglike + 2 * length(rtfit[[3]]$params)
}
```


### `trips` model

```{r modelTrip_rt}
if (use_method == "base") {
  mTrip <- lm(as.formula(paste0("trips ~ ", paste(use_pred_vars, collapse = " + "))),
    data = d_rt
  )
} else if (use_method == "interact") {
  formula_use <- as.formula(paste0("trips ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + projgroup:resil"))
  mTrip <- lm(formula_use, data = d_rt)
} else if (use_method == "projgroupLM") {
  formula_use <- as.formula(paste0("trips ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + resil | projgroup"))
  mTrip <- lmList(formula_use, data = d_rt)
} else if (use_method == "mixedeffects") {
  formula_use <- as.formula(paste0("trips ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + (1+resil|projgroup)"))
  mTrip <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
} else if (use_method == "multitarget") {
  mTrip <- rtfit[[1]]
} else {
  stop("Unknown metamodel approach")
}

if (params$testing) {
  if (use_method == "base" || use_method == "interact") {
    coef(mTrip)
    AIC_trips_rt <- AIC(mTrip)
    sjPlot::tab_model(mTrip)
  } else if (use_method == "projgroupLM") {
    tables <- lapply(mTrip, sjPlot::tab_model)
    tables[[1]]
    AIC_trips_rt_l <- lapply(mTrip, AIC)
    AIC_trips_rt <- sum(unlist(AIC_trips_rt_l))
  } else if (use_method == "mixedeffects") {
    ranef(mTrip)
    AIC_trips_rt <- AIC(logLik(mTrip))
  }
}

if (use_method == "base" || use_method == "interact") {
  if (sd(d_rt$trips) != 0) {
    if (use_method == "base") {
      mTrip_scaled <- lm(as.formula(paste0("scale(trips) ~ ", paste(use_pred_vars, collapse = " + "))),
        data = d_rt
      )
    } else if (use_method == "interact") {
      mTrip_scaled <- lm(as.formula(paste0(
        "scale(trips) ~ ",
        paste(use_add_vars, collapse = " + "),
        " hazard * recovery_num + projgroup:resil"
      )),
      data = d_rt
      )
    }
    sjPlot::tab_model(mTrip_scaled)
  }
}
```

### `miles` model

```{r modelMiles_rt}
if (use_method == "base") {
  mMiles <- lm(as.formula(paste0("miles ~ ", paste(use_pred_vars, collapse = " + "))),
    data = d_rt
  )
} else if (use_method == "interact") {
  formula_use <- as.formula(paste0("miles ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + projgroup:resil"))
  mMiles <- lm(formula_use, data = d_rt)
} else if (use_method == "projgroupLM") {
  formula_use <- as.formula(paste0("miles ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + resil | projgroup"))
  mMiles <- lmList(formula_use, data = d_rt)
} else if (use_method == "mixedeffects") {
  formula_use <- as.formula(paste0("miles ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + (1+resil|projgroup)"))
  mMiles <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
} else if (use_method == "multitarget") {
  mMiles <- rtfit[[2]]
} else {
  stop("Unknown metamodel approach")
}

if (params$testing) {
  if (use_method == "base" || use_method == "interact") {
    coef(mMiles)
    AIC_miles_rt <- AIC(mMiles)
    sjPlot::tab_model(mMiles)
  } else if (use_method == "projgroupLM") {
    tables <- lapply(mMiles, sjPlot::tab_model)
    tables[[1]]
    AIC_miles_rt_l <- lapply(mMiles, AIC)
    AIC_miles_rt <- sum(unlist(AIC_miles_rt_l))
  } else if (use_method == "mixedeffects") {
    ranef(mMiles)
    AIC_miles_rt <- AIC(logLik(mMiles))
  }
}

if (use_method == "base" || use_method == "interact") {
  if (sd(d_rt$miles) != 0) {
    if (use_method == "base") {
      mMiles_scaled <- lm(as.formula(paste0("scale(miles) ~ ", paste(use_pred_vars, collapse = " + "))),
        data = d_rt
      )
    } else if (use_method == "interact") {
      mMiles_scaled <- lm(as.formula(paste0(
        "scale(miles) ~ ",
        paste(use_add_vars, collapse = " + "),
        " hazard * recovery_num + projgroup:resil"
      )),
      data = d_rt
      )
    }
    sjPlot::tab_model(mMiles_scaled)
  }
}
```

### `hours` model

```{r modelHours_rt}
if (use_method == "base") {
  mHours <- lm(as.formula(paste0("hours ~ ", paste(use_pred_vars, collapse = " + "))),
    data = d_rt
  )
} else if (use_method == "interact") {
  formula_use <- as.formula(paste0("hours ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + projgroup:resil"))
  mHours <- lm(formula_use, data = d_rt)
} else if (use_method == "projgroupLM") {
  formula_use <- as.formula(paste0("hours ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + resil | projgroup"))
  mHours <- lmList(formula_use, data = d_rt)
} else if (use_method == "mixedeffects") {
  formula_use <- as.formula(paste0("hours ~ ",
                                   paste(use_add_vars, collapse = " + "),
                                   " hazard * recovery_num + (1+resil|projgroup)"))
  mHours <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
} else if (use_method == "multitarget") {
  mHours <- rtfit[[3]]
} else {
  stop("Unknown metamodel approach")
}

if (params$testing) {
  if (use_method == "base" || use_method == "interact") {
    coef(mHours)
    AIC_hours_rt <- AIC(mHours)
    sjPlot::tab_model(mHours)
  } else if (use_method == "projgroupLM") {
    tables <- lapply(mHours, sjPlot::tab_model)
    tables[[1]]
    AIC_hours_rt_l <- lapply(mHours, AIC)
    AIC_hours_rt <- sum(unlist(AIC_hours_rt_l))
  } else if (use_method == "mixedeffects") {
    ranef(mHours)
    AIC_hours_rt <- AIC(logLik(mMiles))
  }
}

if (use_method == "base" || use_method == "interact") {
  if (sd(d_rt$hours) != 0) {
    if (use_method == "base") {
      mHours_scaled <- lm(as.formula(paste0("scale(hours) ~ ", paste(use_pred_vars, collapse = " + "))),
        data = d_rt
      )
    } else if (use_method == "interact") {
      mHours_scaled <- lm(as.formula(paste0(
        "scale(hours) ~ ",
        paste(use_add_vars, collapse = " + "),
        " hazard * recovery_num + projgroup:resil"
      )),
      data = d_rt
      )
    }
    sjPlot::tab_model(mHours_scaled)
  }
}
```

### Disaggregate transit and car models

```{r modelOthers_rt}
if(run_disaggregate == 'yes'){
  if (use_method == "base") {
    mTrip_lr <- lm(as.formula(paste0("lr_trips ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mTrip_hr <- lm(as.formula(paste0("hr_trips ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mTrip_bus <- lm(as.formula(paste0("bus_trips ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mTrip_car <- lm(as.formula(paste0("car_trips ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mMiles_lr <- lm(as.formula(paste0("lr_miles ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mMiles_hr <- lm(as.formula(paste0("hr_miles ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mMiles_bus <- lm(as.formula(paste0("bus_miles ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mMiles_car <- lm(as.formula(paste0("car_miles ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mHours_lr_w <- lm(as.formula(paste0("lr_hours_wait ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mHours_hr_w <- lm(as.formula(paste0("hr_hours_wait ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mHours_bus_w <- lm(as.formula(paste0("bus_hours_wait ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mHours_lr_e <- lm(as.formula(paste0("lr_hours_enroute ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mHours_hr_e <- lm(as.formula(paste0("hr_hours_enroute ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mHours_bus_e <- lm(as.formula(paste0("bus_hours_enroute ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
    mHours_car <- lm(as.formula(paste0("car_hours ~ ", paste(use_pred_vars, collapse = " + "))), data = d_rt)
  } else if (use_method == "interact") {
    formula_use <- as.formula(paste0("lr_trips ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mTrip_lr <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("hr_trips ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mTrip_hr <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("bus_trips ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mTrip_bus <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("car_trips ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mTrip_car <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("lr_miles ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mMiles_lr <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("hr_miles ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mMiles_hr <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("bus_miles ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mMiles_bus <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("car_miles ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mMiles_car <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("lr_hours_wait ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mHours_lr_w <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("hr_hours_wait ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mHours_hr_w <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("bus_hours_wait ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mHours_bus_w <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("lr_hours_enroute ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mHours_lr_e <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("hr_hours_enroute ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mHours_hr_e <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("bus_hours_enroute ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mHours_bus_e <- lm(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("car_hours ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + projgroup:resil"))
    mHours_car <- lm(formula_use, data = d_rt)
  } else if (use_method == "projgroupLM") {
    formula_use <- as.formula(paste0("lr_trips ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mTrip_lr <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("hr_trips ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mTrip_hr <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("bus_trips ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mTrip_bus <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("car_trips ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mTrip_car <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("lr_miles ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mMiles_lr <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("hr_miles ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mMiles_hr <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("bus_miles ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mMiles_bus <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("car_miles ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mMiles_car <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("lr_hours_wait ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mHours_lr_w <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("hr_hours_wait ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mHours_hr_w <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("bus_hours_wait ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mHours_bus_w <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("lr_hours_enroute ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mHours_lr_e <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("hr_hours_enroute ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mHours_hr_e <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("bus_hours_enroute ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mHours_bus_e <- lmList(formula_use, data = d_rt)
    formula_use <- as.formula(paste0("car_hours ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + resil | projgroup"))
    mHours_car <- lmList(formula_use, data = d_rt)
  } else if (use_method == "mixedeffects") {
    formula_use <- as.formula(paste0("lr_trips ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mTrip_lr <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("hr_trips ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mTrip_hr <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("bus_trips ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mTrip_bus <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("car_trips ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mTrip_car <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("lr_miles ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mMiles_lr <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("hr_miles ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mMiles_hr <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("bus_miles ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mMiles_bus <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("car_miles ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mMiles_car <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("lr_hours_wait ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mHours_lr_w <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("hr_hours_wait ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mHours_hr_w <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("bus_hours_wait ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mHours_bus_w <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("lr_hours_enroute ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mHours_lr_e <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("hr_hours_enroute ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mHours_hr_e <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("bus_hours_enroute ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mHours_bus_e <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
    formula_use <- as.formula(paste0("car_hours ~ ", paste(use_add_vars, collapse = " + "), " hazard * recovery_num + (1+resil|projgroup)"))
    mHours_car <- lmer(formula_use, data = d_rt, control = lmerControl(calc.derivs = FALSE))
  } else if (use_method == "multitarget") {
    mTrip_lr <- rtfit[[4]]
    mTrip_hr <- rtfit[[5]]
    mTrip_bus <- rtfit[[6]]
    mTrip_car <- rtfit[[7]]
    mMiles_lr <- rtfit[[8]]
    mMiles_hr <- rtfit[[9]]
    mMiles_bus <- rtfit[[10]]
    mMiles_car <- rtfit[[11]]
    mHours_lr_w <- rtfit[[12]]
    mHours_hr_w <- rtfit[[13]]
    mHours_bus_w <- rtfit[[14]]
    mHours_lr_e <- rtfit[[15]]
    mHours_hr_e <- rtfit[[16]]
    mHours_bus_e <- rtfit[[17]]
    mHours_car <- rtfit[[18]]
  } else {
    stop("Unknown metamodel approach")
  }
}

# if (params$testing) {
#   if (use_method == "base" || use_method == "interact") {
#     coef(mHours)
#     AIC_hours_rt <- AIC(mHours)
#     sjPlot::tab_model(mHours)
#   } else if (use_method == "projgroupLM") {
#     tables <- lapply(mHours, sjPlot::tab_model)
#     tables[[1]]
#     AIC_hours_rt_l <- lapply(mHours, AIC)
#     AIC_hours_rt <- sum(unlist(AIC_hours_rt_l))
#   } else if (use_method == "mixedeffects") {
#     ranef(mHours)
#     AIC_hours_rt <- AIC(logLik(mMiles))
#   }
# }

# if (use_method == "base" || use_method == "interact") {
#   if (sd(d_rt$hours) != 0) {
#     if (use_method == "base") {
#       mHours_scaled <- lm(as.formula(paste0("scale(hours) ~ ", paste(use_pred_vars, collapse = " + "))),
#         data = d_rt
#       )
#     } else if (use_method == "interact") {
#       mHours_scaled <- lm(as.formula(paste0(
#         "scale(hours) ~ ",
#         paste(use_add_vars, collapse = " + "),
#         " hazard * recovery_num + projgroup:resil"
#       )),
#       data = d_rt
#       )
#     }
#     sjPlot::tab_model(mHours_scaled)
#   }
# }

# full_combos
# select only variables which have more than one combination in full_combos
pred_grid <- full_combos[use_pred_vars]
pred_grid$recovery_num <- as.numeric(as.character(pred_grid$recovery))
```

### RT Extrapolate to other combinations

- Applies coefficients from these models to full combinations.
- Output results.

Extrapolating from `r as.numeric(max_avail_combos)` combinations where core models were run to the full set of `r nrow(pred_grid)` combinations of variables.

```{r generate_predictions_rt}

# Static variables
static_vars <- unlist(lapply(use_levels, function(x) length(x) == 1))
static_values <- d[1, names(d) %in% names(static_vars)[static_vars == TRUE]]

# First three outputs: trips, miles, hours
if (use_method != "multitarget") {
  mTrip_pred <- predict(mTrip, newdata = pred_grid)

  mMiles_pred <- predict(mMiles, newdata = pred_grid)

  mHours_pred <- predict(mHours, newdata = pred_grid)
  
  if(run_disaggregate == 'yes'){
    mTrip_lr_pred <- predict(mTrip_lr, newdata = pred_grid)
    mTrip_hr_pred <- predict(mTrip_hr, newdata = pred_grid)
    mTrip_bus_pred <- predict(mTrip_bus, newdata = pred_grid)
    mTrip_car_pred <- predict(mTrip_car, newdata = pred_grid)
    mMiles_lr_pred <- predict(mMiles_lr, newdata = pred_grid)
    mMiles_hr_pred <- predict(mMiles_hr, newdata = pred_grid)
    mMiles_bus_pred <- predict(mMiles_bus, newdata = pred_grid)
    mMiles_car_pred <- predict(mMiles_car, newdata = pred_grid)
    mHours_lr_w_pred <- predict(mHours_lr_w, newdata = pred_grid)
    mHours_hr_w_pred <- predict(mHours_hr_w, newdata = pred_grid)
    mHours_bus_w_pred <- predict(mHours_bus_w, newdata = pred_grid)
    mHours_lr_e_pred <- predict(mHours_lr_e, newdata = pred_grid)
    mHours_hr_e_pred <- predict(mHours_hr_e, newdata = pred_grid)
    mHours_bus_e_pred <- predict(mHours_bus_e, newdata = pred_grid)
    mHours_car_pred <- predict(mHours_car, newdata = pred_grid)
  }
} else {
  # For multitarget, convert to numeric first. Then use argument `newData` instead of `newdata`
  pred_grid_n <- pred_grid[, use_pred_vars]
  class(pred_grid_n) <- "data.frame"
  for (p in use_pred_vars) {
    pred_grid_n[, p] <- as.numeric(pred_grid_n[, p])
  }

  mTrip_pred <- predict(mTrip, newData = pred_grid_n)
  mMiles_pred <- predict(mMiles, newData = pred_grid_n)
  mHours_pred <- predict(mHours, newData = pred_grid_n)
  
  if(run_disaggregate == 'yes'){
    mTrip_lr_pred <- predict(mTrip_lr, newData = pred_grid_n)
    mTrip_hr_pred <- predict(mTrip_hr, newData = pred_grid_n)
    mTrip_bus_pred <- predict(mTrip_bus, newData = pred_grid_n)
    mTrip_car_pred <- predict(mTrip_car, newData = pred_grid_n)
    mMiles_lr_pred <- predict(mMiles_lr, newData = pred_grid_n)
    mMiles_hr_pred <- predict(mMiles_hr, newData = pred_grid_n)
    mMiles_bus_pred <- predict(mMiles_bus, newData = pred_grid_n)
    mMiles_car_pred <- predict(mMiles_car, newData = pred_grid_n)
    mHours_lr_w_pred <- predict(mHours_lr_w, newData = pred_grid_n)
    mHours_hr_w_pred <- predict(mHours_hr_w, newData = pred_grid_n)
    mHours_bus_w_pred <- predict(mHours_bus_w, newData = pred_grid_n)
    mHours_lr_e_pred <- predict(mHours_lr_e, newData = pred_grid_n)
    mHours_hr_e_pred <- predict(mHours_hr_e, newData = pred_grid_n)
    mHours_bus_e_pred <- predict(mHours_bus_e, newData = pred_grid_n)
    mHours_car_pred <- predict(mHours_car, newData = pred_grid_n)
  }
}

if(run_disaggregate == 'yes'){
  preds <- data.frame(static_values, pred_grid,
    trips = mTrip_pred,
    miles = mMiles_pred,
    hours = mHours_pred,
    lr_trips = mTrip_lr_pred,
    hr_trips = mTrip_hr_pred,
    bus_trips = mTrip_bus_pred,
    car_trips = mTrip_car_pred,
    lr_miles = mMiles_lr_pred,
    hr_miles = mMiles_hr_pred,
    bus_miles = mMiles_bus_pred,
    car_miles = mMiles_car_pred,
    lr_hours_wait = mHours_lr_w_pred,
    hr_hours_wait = mHours_hr_w_pred,
    bus_hours_wait = mHours_bus_w_pred,
    lr_hours_enroute = mHours_lr_e_pred,
    hr_hours_enroute = mHours_hr_e_pred,
    bus_hours_enroute = mHours_bus_e_pred,
    car_hours = mHours_car_pred
  )
} else {
  preds <- data.frame(static_values, pred_grid,
    trips = mTrip_pred,
    miles = mMiles_pred,
    hours = mHours_pred
  )
}
preds <- preds %>% select(-recovery_num)

if (!dir.exists(output_dir)) {
  dir.create(output_dir)
}

write.csv(preds,
  file = file.path(output_dir, paste0("Metamodel_scenarios_RT_futureyear_", run_id, ".csv")),
  row.names = FALSE
)
```

```{r datatab_rt}
# Not including transit and car specific metrics
DT::datatable(preds,
  caption = "Extrapolated values for RT routing solution"
) %>%
  formatRound(
    columns = c("trips", "miles", "hours"),
    digits = 0
  ) %>%
  formatStyle(
    "trips",
    background = styleColorBar(preds$trips, "steelblue"),
    backgroundSize = "100% 90%",
    backgroundRepeat = "no-repeat",
    backgroundPosition = "center"
  ) %>%
  formatStyle(
    "miles",
    background = styleColorBar(preds$miles, "salmon"),
    backgroundSize = "100% 90%",
    backgroundRepeat = "no-repeat",
    backgroundPosition = "center"
  ) %>%
  formatStyle(
    "hours",
    background = styleColorBar(preds$hours, "seagreen"),
    backgroundSize = "100% 90%",
    backgroundRepeat = "no-repeat",
    backgroundPosition = "center"
  )
```


```{r output_AIC, eval= params$testing =='true'}
# Not including transit and car specific metrics
AIC_out <- data.frame(
  Method = use_method,
  response = rep(c("Trips", "Miles", "Hours"), times = 2),
  Run_Type = rep(c("SP", "RT"), each = 3),
  AIC = c(
    AIC_trips_sp,
    AIC_miles_sp,
    AIC_hours_sp,
    AIC_trips_rt,
    AIC_miles_rt,
    AIC_hours_rt
  )
)

aic_file <- paste0("AIC_", params$run_id, "_out.csv")

if (!file.exists(file.path(params$output_dir, aic_file))) {
  write.csv(AIC_out, file.path(params$output_dir, aic_file),
    row.names = FALSE
  )
} else {
  write.table(AIC_out, file.path(params$output_dir, aic_file),
    append = TRUE, col.names = FALSE, sep = ",",
    row.names = FALSE
  )
}

# TODO:
# Also generate warning if mixedeffect model is singular
# (meaning, too complex for the data, overfitted)
# https://rdrr.io/cran/lme4/man/isSingular.html
# Attempting to improve lmer performance for mixed effect models https://cran.r-project.org/web/packages/lme4/vignettes/lmerperf.html
```
